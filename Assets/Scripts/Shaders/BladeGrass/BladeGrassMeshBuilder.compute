// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

// Import some helper functions
#include "NMGBladeGrassComputeHelpers.hlsl"

// This describes a vertex on the source mesh
struct SourceVertex {
    float3 positionOS;
};
// Source buffers, arranged as a vertex buffer and index buffer
StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceIndices;

// This describes a vertex on the generated mesh
struct GeneratedVertex {
    float3 positionOS;
    float3 normalOS;
    float2 uv;
};
// Source and index buffers for the generated mesh
RWStructuredBuffer<GeneratedVertex> _GeneratedVertices;
RWStructuredBuffer<int> _GeneratedIndices;

int _NumSourceTriangles;
float _BladeHeight;
float _BladeWidth;
float4x4 _Transform;
int _NumBladeSegments;
float _BladeCurvature;

void GetCenterAndBasis(SourceVertex a, SourceVertex b, SourceVertex c, out float3 positionOS, out float3 normalOS, out float3x3 tsToOs) {

    float3 posA = mul(_Transform, float4(a.positionOS, 1)).xyz;
    float3 posB = mul(_Transform, float4(b.positionOS, 1)).xyz;
    float3 posC = mul(_Transform, float4(c.positionOS, 1)).xyz;

    // Then get the center point
    positionOS = GetTriangleCenter(posA, posB, posC);
    // and the normal vector and TS -> OS transformation matrix
    GetTriangleNormalAndTSMatrix(posA, posB, posC, normalOS, tsToOs);
}

// This function calculates values for the output point
GeneratedVertex MakeGeneratedPoint(float3 anchorOS, float3 normalOS, float2 dimensions, float3x3 tsToOs, float2 uv) {
    // Calculate the offset in tangent space based on the UV and width/height
    float3 offsetTS = float3((uv.x - 0.5f) * dimensions.x, 0, uv.y * dimensions.y);
    // Calculate the offset in world space using the rotation matrix
    float3 offsetOS = mul(tsToOs, offsetTS);

    GeneratedVertex output = (GeneratedVertex)0;
    output.positionOS = anchorOS + offsetOS;
    output.normalOS = normalOS;
    output.uv = uv;
    return output;
}

// This is the number of threads to create per dispatch. This kernel only uses the
// x value, so you can fine tune that if needed
[numthreads(128, 1, 1)]
void Main(uint3 id : SV_DispatchThreadID) {
    // Disptaches can only be in chunks of 128, there might be more threads than number
    // of triangles. Return in that case
    if ((int)id.x >= _NumSourceTriangles) {
        return;
    }

    // Get the vertices which make up this triangle
    // The index array contains indices into the vertex array
    // Three values in the index array describe one triangle in the source mesh
    int sourceTriStart = id.x * 3;
    // Get the triangle center, normal vector, and tangent-to-object space transformation matrix
    float3 positionOS, normalOS;
    float3x3 tsToOs;
    GetCenterAndBasis(
        _SourceVertices[_SourceIndices[sourceTriStart + 0]],
        _SourceVertices[_SourceIndices[sourceTriStart + 1]],
        _SourceVertices[_SourceIndices[sourceTriStart + 2]],
        positionOS, normalOS, tsToOs);

    float2 dimensions = float2(_BladeWidth, _BladeHeight);

    // Create an array to hold blade points
    GeneratedVertex vertices[3];

    vertices[0] = MakeGeneratedPoint(positionOS, normalOS, dimensions, tsToOs, float2(0, 0)); // Left
    vertices[1] = MakeGeneratedPoint(positionOS, normalOS, dimensions, tsToOs, float2(1, 0)); // Right
    vertices[2] = MakeGeneratedPoint(positionOS, normalOS, dimensions, tsToOs, float2(0.5, 1)); // Tip

    // Calculate the positions to insert these vertices and this triangle into the generated mesh arrays
    int numGenVertices = 3;
    int numGenTriangles = 1;
    int numGenIndices = numGenTriangles * 3; // Three indices per triangle
    int genIndexStart = id.x * numGenIndices;
    int genVertexStart = id.x * numGenVertices;

    for (int i = 0; i < 3; i++) {
        _GeneratedVertices[genVertexStart + i] = vertices[i];
    }
    for (int i = 0; i < 3; i++) {
        _GeneratedIndices[genIndexStart + i] = genVertexStart + i;
    }
}